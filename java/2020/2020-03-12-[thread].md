#Java并发实战
## 一、并发理论基础
### 1.1 并发编程出现BUG 的源头
    缓存导致的【可见性】问题
    线程切换带来的【原子性】问题
    编译器优化带来的【有序性】问题
     
### 1.2 Java内存模型：看Java如何解决可见性和有序性问题
    Happers-Before 六项原则：
    1、程序的顺序性原则
    2、volatile 变量规则
    3、传递性
    4、管程中锁的原则
    5、线程start()原则
    6、线程join()原则
    
    java 内存模型总结：
   
    1. 为什么定义Java内存模型？现代计算机体系大部是采用的对称多处理器的体系架构。
    每个处理器均有独立的寄存器组和缓存，多个处理器可同时执行同一进程中的不同线程，这里称为处理器的乱序执行。
    在Java中，不同的线程可能访问同一个共享或共享变量。
    如果任由编译器或处理器对这些访问进行优化的话，很有可能出现无法想象的问题，这里称为编译器的重排序。
    除了处理器的乱序执行、编译器的重排序，还有内存系统的重排序。
    因此Java语言规范引入了Java内存模型，通过定义多项规则对编译器和处理器进行限制，主要是针对可见性和有序性。
    
    2. 三个基本原则：原子性、可见性、有序性。
   
    3. Java内存模型涉及的几个关键词：锁、volatile字段、final修饰符与对象的安全发布。其中：第一是锁，锁操作是具备happens-before关系的，解锁操作happens-before之后对同一把锁的加锁操作。实际上，在解锁的时候，JVM需要强制刷新缓存，使得当前线程所修改的内存对其他线程可见。第二是volatile字段，volatile字段可以看成是一种不保证原子性的同步但保证可见性的特性，其性能往往是优于锁操作的。但是，频繁地访问 volatile字段也会出现因为不断地强制刷新缓存而影响程序的性能的问题。第三是final修饰符，final修饰的实例字段则是涉及到新建对象的发布问题。当一个对象包含final修饰的实例字段时，其他线程能够看到已经初始化的final实例字段，这是安全的。
   
    4. Happens-Before的7个规则：
    (1).程序次序规则：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。
    (2).管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而"后面"是指时间上的先后顺序。
    (3).volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的"后面"同样是指时间上的先后顺序。
    (4).线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作。
    (5).线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join（）方法结束、Thread.isAlive（）的返回值等手段检测到线程已经终止执行。
    (6).线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。
    (7).对象终结规则：一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始。
   
    5. Happens-Before的1个特性：传递性。
   
    6. Java内存模型底层怎么实现的？主要是通过内存屏障(memory barrier)禁止重排序的，即时编译器根据具体的底层体系架构，将这些内存屏障替换成具体的 CPU 指令。对于编译器而言，内存屏障将限制它所能做的重排序优化。而对于处理器而言，内存屏障将会导致缓存的刷新操作。比如，对于volatile，编译器将在volatile字段的读写操作前后各插入一些内存屏障。

### 1.3 互斥锁（上）：解决原子性问题
    互斥保证同一时刻只有一个线程在执行
    
    实现互斥的方式：
    1、synchronized
    synchronized作用范围可以是类，静态方法、非静态方法、代码块
    
    ***:当修饰静态方法的时候，锁定的是当前类的 Class 对象，当修饰非静态方法的时候，锁定的是当前实例对象 this。
    
### 1.4 互斥锁（下）：如何用一把锁保护多个资源？
     1、当多个资源之间没有任何关系时--为每个资源都加上一把锁即可
     2、多个资源之间存在关系，例如银行转账业务。选择一个粒度更大的锁，这个锁应该能够覆盖所有相关的资源。
     
     PS： 根据资源的关系，确定锁的粒度大小，到底对什么资源进行加锁
     
     可变对象不能作为锁