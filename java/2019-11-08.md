# java 开发规范【基于阿里巴巴Java开发规范】

## 一、编程规约
### 1.1.命名风格
1、代码中的命名均不能以下划线和美元符号开始，也不能以此结尾。

反例：-name/$name/name-/name$

2、代码中的命名严禁使用拼音和英文混合的方式，更不允许直接使用中文的方式。

3、类名使用UpperCamelCase风格，但下列情形除外：DO/PO/DTO/VO/BO等

4、方法名、参数名、变量名均使用lowerCamelCase风格

如：getHttpMessage()/inputName/userName

5、常量名统一使用大写字母，单词之间使用下划线连接，力求表达清楚含义，不要嫌名字长

如：CACHE_EXPIRED_TIME

6、抽象类命名使用 Abstract 或 Base 开头； 异常类命名使用 Exception 结尾； 测试类
命名以它要测试的类的名称开始，以 Test 结尾。

7、类型与中括号紧挨相连来表示数组。

8、POJO 类中布尔类型的变量，都不要加 is 前缀，否则部分框架解析会引起序列化错误。

9、包名统一使用小写，点分隔符之间有且仅有一个自然语言的英语单词。并且包名统一使用单数形式。如果类名有复数形式可以使用复数。

10、杜绝安全不规范的缩写，避免望文生义。不要长，将每个类名、属性、方法完整表达清楚。

11、接口中的方法和属性不要添加任何修饰符（public也不要加），并加上有效的javadoc 注释。

12、枚举类名建议带上Enum后缀，枚举成员名称需要全大写，单词间用下划线隔开。

13、各层命名规范：
    A)Service/DAO层

	 1）获取单个对象的方法用get作为前缀
	
	 2）获取多个对象的方法用list作为前缀，复数形式结尾如：listObjects。
	
	 3）获取统计值的方法用count()
	
	 4)插入方法使用save/insert 作为前缀
	
	 5）删除方法用remove/delete作为前缀
	
	 6）修改方法使用update作为前缀
	
	B)领域命名规范
	
	 1）数据对象：xxxDO,xxx表示数据表名
	
	 2）数据传输对象，xxxDTO，xxx为业务相关的名称
	
	 3）展示对象：xxxVO，xxx一般为网页名称
	
	 4）POJO为DO/DTO/BO/VO的统称，禁止使用xxxPOJO命名 

### 1.2.常量定义

1、不允许使用任何魔法值（未经预先定义的常量）直接在代码中使用

如：String key = "Id#taoabo"+tableId;

2、在使用long或者Long 类型时，数值后要使用大写L,不能使用小写，容易和数字1混淆

3、不要使用一个常量类维护所有常量， 要按常量功能进行归类，分开维护。

说明： 大而全的常量类， 杂乱无章， 使用查找功能才能定位到修改的常量，不利于理解和维护。

4、如果变量值仅在一个固定范围内变化用 enum 类型来定义。

说明： 如果存在名称之外的延伸属性应使用 enum 类型，下面正例中的数字就是延伸信息，表示一年中的
第几个季节。

正例：
```
     public enum SeasonEnum {
    	   SPRING(1), SUMMER(2), AUTUMN(3), WINTER(4);
    	    private int seq;
       SeasonEnum(int seq) {
    	   this.seq = seq;
    	}
    	public int getSeq() {
    	  return seq;
    	   }
    	}
```

### 1.3.代码格式
1、如果是大括号内为空，则简洁地写成{}即可，大括号中间无需换行和空格；如果是非
空代码块则：

	1） 左大括号前不换行。
	
	2） 左大括号后换行。
	
	3） 右大括号前换行。
	
	4） 右大括号后还有 else 等代码则不换行；表示终止的右大括号后必须换行。

2、左小括号和字符之间不出现空格；同样，右小括号和字符之间也不出现空格；而左
大括号前需要空格。

3、if/for/while/switch/do 等保留字与括号之间都必须加空格。

4、任何二目、 三目运算符的左右两边都需要加一个空格。

5、采用 4 个空格缩进，禁止使用 tab 字符。

```
正例： （涉及 1-5 点）
public static void main(String[] args) {
// 缩进 4 个空格
String say = "hello";
// 运算符的左右必须有一个空格
int flag = 0;
// 关键词 if 与括号之间必须有一个空格，括号内的 f 与左括号，0 与右括号不需要空格
if (flag == 0) {
System.out.println(say);
}
// 左大括号前加空格且不换行；左大括号后换行
if (flag == 1) {
System.out.println("world");
// 右大括号前换行，右大括号后有 else，不用换行
} else {
System.out.println("ok");
// 在右大括号后直接结束，则必须换行
}
}
```

6、注释的双斜线与注释内容之间有且仅有一个空格。

如：

// 这是示例注释，请注意在双斜线之后有一个空格

String param = new String();

7、方法参数在定义和传入时，多个参数逗号后边必须加空格。

8、IDE 的 text file encoding 设置为 UTF-8; IDE 中文件的换行符使用 Unix 格式，不
要使用 Windows 格式。
 
9、单个方法的总行数不超过 80 行。

10、不同逻辑、不同语义、不同业务的代码之间插入一个空行分隔开来以提升可读性。
 
### 1.4.OOP规范
1、避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析
成本，直接用类名来访问即可。

2、所有的覆写方法，必须加@Override 注解。

3、方法参数超过3个就封装为对象

4、不要使用过时的类和方法

5、外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产
生影响。接口过时必须加@Deprecated 注解，并清晰地说明采用的新接口或者新服务是什
么。

6、Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用
equals。

如："test".equals(object); 而不是 object.equals("test");

7、所有整型包装类对象之间值的比较， 全部使用 equals 方法比较。

说明： 对于 Integer var = ? 在-128 至 127 范围内的赋值， Integer 对象是在 IntegerCache.cache 产
生，会复用已有对象，这个区间内的 Integer 值可以直接使用==进行判断，但是这个区间之外的所有数
据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用 equals 方法进行判断。

8、浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型统一改为BigDecimal 类型进行
equals 来判断。

9、定义数据对象 DO 类时，属性类型要与数据库字段类型相匹配。

如：数据库字段的 bigint 必须与类属性的 Long 类型相对应。如果 id 字段定义类型 bigint unsigned，实际类对象属性为 Integer，随着 id 越来越大，超过 Integer 的表示范围而溢出成为负数。

10、 为了防止精度损失， 禁止使用构造方法 BigDecimal(double)的方式把 double 值转
化为 BigDecimal 对象。

优先推荐：入参为 String 的构造方法，或使用 BigDecimal 的 valueOf 方法，此方法内部其实执行了
Double 的 toString，而 Double 的 toString 按 double 的实际能表达的精度对尾数进行了截断。

如： 

	BigDecimal recommend1 = new BigDecimal("0.1");
	BigDecimal recommend2 = BigDecimal.valueOf(0.1);

## 五、编程规约
### 5.1.建表约束
1、表达是否概念的字段，使用is_xxx的方式命名，数据类型使用unsigned tinyint(1为是，0为否)

2、表名、字段名使用小写字母或者数字，但是禁止使用数字开头，禁止两个下划线之间只出现数字

正例：user_name,level3_name

反例：UserName,level_3_name

3、表名不要使用复数

4、禁用mysql中的关键字(保留字)，如desc、asc、range、select、detete 等。

5、主键索引使用pk_字段名；唯一索引使用 uk_字段名；普通索引使用idx_字段名。

6、小数类型为 decimal，禁止使用 float 和 double。
说明： 在存储的时候， float 和 double 都存在精度损失的问题，很可能在比较值的时候，得到不正确的
结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数并分开存储

7、如果存储的字符串长度几乎相等，使用 char 定长字符串类型。

8、varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长
度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索
引效率。

9、表必备三字段： id, create_time, update_time。

说明：其中 id 必为主键，类型为 bigint unsigned、单表时自增、步长为 1。 create_time, update_time
的类型均为 datetime 类型。

10、库名与应用一致、表的命名最好是遵循“业务名称_表的作用” 。

### 5.2.索引约束
1、业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。
说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，
即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。

2、 超过三个表禁止join。需要 join 的字段，数据类型必须绝对一致；多表关联查询
时，保证被关联的字段需要有索引。--但经常出现超过三个表的jion :(

3、在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据
实际文本区分度决定索引长度即可。

4、页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。
说明：索引文件具有B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。

5、如果有 order by 的场景，请注意利用索引的有序性。 order by 最后的字段是组合
索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort 的情况，影响查询性能。

6、 SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，如果可以是
consts 最好。
说明：
1） consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。
2） ref 指的是使用普通的索引（normal index）。
3） range 对索引进行范围检索。
反例：explain 表的结果，type=index，索引物理文件全扫描，速度非常慢，这个 index 级别比较 range
还低，与全表扫描是小巫见大巫。

7、不要使用 count(列名)或 count(常量)来替代 count(*)，count(*)是 SQL92 定义的
标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。
说明：count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。

8、count(distinct col) 计算该列除 NULL 之外的不重复行数，注意 count(distinct 
col1, col2) 如果其中一列全为 NULL，那么即使另一列有不同的值，也返回为 0。

9、当某一列的值全是 NULL 时，count(col)的返回结果为 0，但 sum(col)的返回结果
为 NULL，因此使用 sum()时需注意 NPE 问题。

10、使用 ISNULL()来判断是否为 NULL 值。

说明：NULL 与任何值的直接比较都为 NULL。 1） NULL<>NULL 的返回结果是 NULL，而不是 false。 2） NULL=NULL 的返回结果是 NULL，而不是 true。 3） NULL<>1 的返回结果是 NULL，而不是 true。

11、代码中写分页查询逻辑时，若 count 为 0 应直接返回，避免执行后面的分页语句。

12、不得使用外键与级联，一切外键概念必须在应用层解决。

说明：以学生和成绩的关系为例，学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外
键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级
联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风
险；外键影响数据库的插入速度。

13、禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。

14、数据订正（特别是删除、修改记录操作）时，要先 select，避免出现误删除，确认无
误才能执行更新语句。

15、in 操作能避免则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量，控
制在 1000 个之内。